# 1.3 缓存、验证码、登录、表单验证

## Django 中的缓存

1. 接口及用法

   ```python
   from django.core.cache import cache
   
   # 在缓存中设置 age = 123, 10秒过期
   # 缓存默认存在内存中
   cache.set('age', 123, 10)
   
   # 获取 age
   a = cache.get('age')
   print(a)
   
   # 自增
   x = cache.incr('age')
   print(x)
   ```

2. 使用 Redis 做缓存后端

   - 安装 `pip install django-redis`

   - settings 配置

     ```python
     CACHES = {
         "default": {
             "BACKEND": "django_redis.cache.RedisCache",
             "LOCATION": "redis://127.0.0.1:6379/0",
             "OPTIONS": {
                 "CLIENT_CLASS": "django_redis.client.DefaultClient",
                 "PICKLE_VERSION": -1,
             }
         }
     }
     ```

3. 利用过期时间可以处理一些定时失效的临时数据, 比如手机验证码

4. 如何访问Redis数据

   1. 图形界面工具：Medis，RDM收费了
   2. 命令行：redis-cli --raw(查看中文等)
   3. python程序访问：
      1. Django shell ： python manage.py shell

5. 面试题：

   1. 如何用Redis做缓存？
   2. Redis还可以做排序？
   3. zset(sorted set)有序集合？zset是如何实现有序的？skiplist跳表

## Cookie、 Session 机制剖析

1. 回顾 HTTP 协议

   1. host
      1. linux: /etc/hosts
      2. windows: C:/Windows/System32/drivers/etc/hosts

2. Session和Cookie的产生过程

   1. 浏览器: 向服务器发送请求
   2. 服务器: 接受并创建 session 对象 (该对象包含一个 **session_id**)
   3. 服务器: 执行 views 函数, 并得到一个 response 对象
   4. 服务器: 执行 response.set_cookie('sessionid', session_id) 将 session_id 写入 cookie
   5. 服务器: 将 response 传回浏览器
   6. 浏览器: 读取 response 报文, 从 Cookies 取出 session_id 并保存，保存到浏览器的Cookie存储中

3. 浏览器后续后续请求

   1. 浏览器: 向服务器发送请求时，浏览器自动把 session_id 随 Cookies 一同发给 Server
   2. 服务器: 从 Headers 的 Cookies 中取出 session_id
   3. 服务器: 根据 session_id 找出对应的数据, 确认客户端身份
   4. 服务器：如果没有session_id,那就当成一个新用户，让他去登录

4. Django 中的代码实现

   ```python
   class SessionMiddleware(MiddlewareMixin):
       def __init__(self, get_response=None):
           self.get_response = get_response
           engine = import_module(settings.SESSION_ENGINE)
           self.SessionStore = engine.SessionStore  # 设置 Session 存储类
   
       def process_request(self, request):
           # 从 Cookie 获取 sessionid
           session_key = request.COOKIES.get('session_id')
   
           # 通过 session_key 获取之前保存的数据
           request.session = self.SessionStore(session_key)
   
       def process_response(self, request, response):
           try:
               # View 函数结束后, 获取 session 状态
               accessed = request.session.accessed
               modified = request.session.modified
               empty = request.session.is_empty()
           except AttributeError:
               pass
           else:
               # 如果 Cookie 中有 sessionid, 但 session 为空,
               # 说明 view 中执行过 session.flush 等清除session的操作,
               # 直接删除 Cookie 中的 session
               if 'session_id' in request.COOKIES and empty:
                   response.delete_cookie(
                       settings.SESSION_COOKIE_NAME,
                       path=settings.SESSION_COOKIE_PATH,
                       domain=settings.SESSION_COOKIE_DOMAIN,
                   )
               else:
                   if accessed:
                       patch_vary_headers(response, ('Cookie',))
                   if (modified or settings.SESSION_SAVE_EVERY_REQUEST) and not empty:
                       # 设置过期时间
                       if request.session.get_expire_at_browser_close():
                           max_age = None
                           expires = None
                       else:
                           max_age = request.session.get_expiry_age()
                           expires_time = time.time() + max_age
                           expires = cookie_date(expires_time)
   
                       # 保存会话数据, 并刷新客户端 Cookie
                       if response.status_code != 500:
                           try:
                               request.session.save()
                           except UpdateError:
                               raise SuspiciousOperation(
                                   "The request's session was deleted before the "
                                   "request completed. The user may have logged "
                                   "out in a concurrent request, for example."
                               )
   
                           # 让客户端将 sessionid 添加到 Cookie 中
                           response.set_cookie(
                               'session_id',
                               request.session.session_key,
                               max_age=max_age,
                               expires=expires,
                               domain=settings.SESSION_COOKIE_DOMAIN,
                               path=settings.SESSION_COOKIE_PATH,
                               secure=settings.SESSION_COOKIE_SECURE or None,
                               httponly=settings.SESSION_COOKIE_HTTPONLY or None,
                           )
           return response
   ```
   
5. 面试题：

   1. 如何区分 Cookie、Session？
   2. 请描述 HTTP 协议

## 验证短信

1. urls.py 增加新的url路由映射
   1. url(r'api/user/submit/vcode', user_api.submit_vcode)
2. 实现路由映射：
   1. submit_vcode
      1. 获取手机号、验证码
      2. 取出缓存里的对应这个手机号的验证码
      3. 检查验证码一致，登录，如果发现这个用户不存在，就自动注册
      4. 不一致返回错误
      5. 返回错误信息之后，由前端负责提示用户，跳转后续页面

## 中间件

1. Django：中间件：整个框架拦截Request和Response的一系列动作
2. **Java：中间件：程序与数据库之间的衔接组件，或者不同程序之间的衔接组件**
   1. **消息队列**
   2. 缓存



## 个人资料接口规划

1. 获取个人资料(社交条件)接口
2. 修改个人资料接口
3. 上传个人头像接口


## Profile 模型设计 (仅作参考)

| Field          | Description              |
| -------------- | ------------------------ |
| location       | 目标城市                 |
| min_distance   | 最小查找范围             |
| max_distance   | 最大查找范围             |
| min_dating_age | 最小交友年龄             |
| max_dating_age | 最大交友年龄             |
| dating_sex     | 匹配的性别               |
| vibration      | 开启提醒震动             |
| only_matche    | 不让未匹配的人看我的相册 |
| auto_play      | 自动播放视频             |


## 开发中的难点

1. Profile 与 User 两个模型是什么关系 ？一对一、一对多、多对多
   1. 取决于产品设计，取决于需求。
2. 企业中不使用外键如何构建 "表关联" ？
   1. 用不用外键：
      1. 100万以上条目的表就不要用了
      2. 传统型企业，业务极其复杂的，会使用外键
      3. 分布式无法用外键
3. 接口中有太多字段批量提交时应如何验证 ？
   1. 简化表单验证
4. 如何上传头像 ？<https://docs.djangoproject.com/zh-hans/2.0/topics/http/file-uploads/>
   1. 传到云服务上
5. 大型项目中如何保存大量的静态文件 ？
   1. 如何保存，如何更快的分发给用户：CDN
6. 上传文件、发送验证码、图像处理等较慢操作应如何处理才能让用户等待时间更短 ？
   1. 用异步方式


## 数据库表关系的构建

1. 关系分类
    - 一对一关系
    - 一对多关系
    - 多对多关系：额外加一张表来保存关系

2. 外键的优缺点
    - 优点:
        - 由数据库自身保证数据一致性和完整性, 数据更可靠
        - 可以增加 **E-R 图**：正统学院派的方式：Entity Relationship Diagram 的可读性
          - django里面一样写modle，只是不要做迁移就可以了。
        - 外键可节省开发量
    - 缺点:
        - 性能缺陷, 有额外开销
        - 主键表被锁定时, 会引发外键对应的表也被锁
        - 删除主键表的数据时, 需先删除外键表的数据
        - 修改外键表字段时, 需重建外键约束
        - **不能用于分布式环境**
    - 不容易做到数据解耦
    
3. 应用场景
    - 适用场景: 内部系统、传统企业级应用可以使用 (需要数据量可控, 数据库服务器数量可控)
    - 不适用场景: 互联网行业不建议使用

4. 手动构建关联
    1. 一对一: 主表 id 与 子表 id 完全一一对应
    2. 一对多: 在 "多" 的表内添加 "唯一" 表 id 字段
    3. 多对多: 多创建一个关系表, 关系表中一般只存放两个相关联的条目的 id
    4. 博客案例思考
        1. 用户和微博的关系：一对多
        2. 用户和收藏关系：多对多
        3. 用户-角色-权限关系
       1. 用户-角色：一对多
           2. 角色-权限：多对多
    
5. 可通过 `property` 的方式对子表进行关联操作

    - property 用法

        ```python
        class Box:
            def __init__(self):
                self.l = 123
                self.w = 10
                self.h = 80

            @property
            def V(self):
                return self.l * self.w * self.h

        b = Box()
        print(b.V)
        ```

    - 对子表关联操作

        ```python
        class User(models.Model):
            ...
            user_id = models.IntergerField()
            ...
        
            @property
            def user_profile(self):
                if not hasattr(self, '_profile'):
                    self._profile = Profile.objects.get(user_id=self.user_id)
                return self._profile
    
        
        
        class User(models.Model):
        		...
            demo_id = models.IntegerField()
            ...
        
            @property
        		def demo(self):
                if not hasattr(self, '_demo'):
                self._demo = Demo.objects.get(id=self.demo_id)
                return self._demo
        
        ```
    
    
    
    - 也可以使用 cached_property 对属性值进行缓存
    
        ```python
        from django.utils.functional import cached_property
    
        class User(models.Model):
            year = 1990
            month = 10
            day = 29
    
            @cached_property
            def age(self):
                today = datetime.date.today()
                birth_date = datetime.date(self.year, self.month, self.day)
                times = today - birth_date
                return times.days // 365
        ```

- 面试题：
  - 复杂SQL查询：分组、连接
    - Student表有：id和name字段
    - Score表有：student_id, exam_id, object_id, score
    - 求：
      1. 某次考试成绩最好的学生
    - 分组、统计函数、连接
    - 进阶思考：窗口函数
      - 每次考试成绩前三的学生？
      - 序号函数：row_number() / rank() / dense_rank()
      - 分布函数：percent_rank() / cume_dist()
      - 前后函数：lag() / lead()
      - 头尾函数：first_val() / last_val()
      - 其他函数：nth_value() / nfile()

## Django 中的 Form 表单验证

- Django Form 核心功能：数据验证

- 网页中 `<form>` 标签
    - `<form>` 标签的 method 只能是 POST 或 GET
    - method=POST 时，表单数据在请求的 body 部分
    - method=GET 时, 表单数据会出现在 URL 里

- Form 对象的属性和方法
    - `form.is_valid()` : 表单验证
    - `form.has_changed()` : 检查是否有修改
    - `form.clean_<field>()` : 针对某字段进行特殊清洗和验证
    - `form.cleaned_data['fieldname']` : 清洗后的数据存放于这个属性

- Form 的定义和使用

    ```python
    from django import forms

    class TestForm(forms.Form):
        TAGS = (
            ('py', 'python'),
            ('ln', 'linux'),
            ('dj', 'django'),
        )
        fid = forms.IntegerField()
        name = forms.CharField(max_length=10)
        tag = forms.ChoiceField(choices=TAGS)
        date = forms.DateField()

    POST = {'fid': 'bear',
            'name': 'hello-1234567890',
            'tag': 'django',
            'date': '2017/12/17'}
    form = TestForm(POST)
    print(form.is_valid())
    print(form.cleaned_data)  # cleaned_data 属性是 is_valid 函数执行时动态添加的
    print(form.errors)
    ```

- ModelForm 可以通过相应的 Model 创建出 Form

    ```python
    class UserForm(ModelForm):
        class Meta:
            model = User
            fields = ['name', 'birth']
    ```

## 云服务市场

1. Serverless架构
   1. 函数计算，lambda
2. 公有云：
   1. 用什么服务
      1. Django
         1. 负载均衡服务
         2. 云服务器1，用作 web server: NginX->upstream
         3. 云服务器2..n用作 app(lication) server，运行我们的python程序: Gunicorn + Django
         4. 云缓存Redis
         5. 云数据库MySQL（一主多从带备份的集群），解决的主要是：备份、维护
            1. 未来做分布式还是要自己实现
            2. 2019新式的数据库可以做到自动分布式。
   2. 云服务器：**EC2**，ECS
      1. 实例类型：
         1. 均衡型1v 1G / 2v 4G / 4v 8G / 8v 16G
         2. 内存型
         3. 计算型
      2. GPU实例
         1. 科学计算用
   3. 云存储：**S3**，OSS
   4. 云数据库：
      1. RMDB：MySQL、PostgreSQL
      2. NoSQL：get/set
      3. Documents:MongoDB
   5. 云缓存：Redis
   6. 消息队列：SQS
   7. 全文索引：Elastic Search
   8. 数据仓库：
   9. Mobile服务
   10. 统计服务
   11. 机器学习
   12. 大数据计算
   13. 代码提交构建部署的服务
3. **AWS**：亚马逊：Amazon Web Service，全球领先
   1. 云服务器：EC2：elastic cloud computer
   2. 云存储：S3：simple storage service
   3. 云数据库：RDS：relationship database service：MySQL
   4. 消息队列：SQS：Simple Queue Service
   5. 全文检索：
   6. 云数据仓库：redshift
   7. 几百种服务
4. Azure：微软：非常多的linux服务器，各种服务都有
5. Google Cloud
   1. 云存储比较便宜TB
6. **阿里云**：国内第一
   1. 云服务器：ECS
   2. 云存储：OSS
   3. 云数据库：RDS
7. 华为云：
   1. 存储
   2. 计算、存储、数据库、机器学习
   3. 分布式数据库中间件 DDM（第二周讲）
   4. 图引擎服务 GES：Graph database
8. 腾讯云：
   1. 
9. 不值一提的云：
   1. 金山云
   2. 百度云
10. 专用云：
  1. 存储：
     1. 七牛
        1. 图片缩放：
           1. 新建图片样式
           2. 选择自己想要的缩放方式
           3. 起名字
           4. 保存
           5. 使用方法：
              1. http://pvhv7tfry.bkt.clouddn.com/space_city.jpg?imageView2/1/w/200/h/200/q/75|imageslim
        2. 图片的渐进式显示：
           1. 
     2. 又拍云
  2. 直播：
  3. 短信：云之讯
  4. 邮件：sendcloud
11. 上云之后服务的构建方法：
    1. 只用云服务器，其他都自己在云服务器里实现
       1. 不依赖云，换云或离开的成本极低
       2. 用的人多，开发周期长
    2. 充分利用各种云服务
       1. 节约人力成本，用的人少，开发周期短
       2. 依赖于云服务，换云或者离开云的成本高
       3. 在云上自己做高可用
12. **DDoS**
    1. DoS：拒绝服务攻击
    2. DDoS：分布式拒绝服务攻击：10G、100G
       1. 成本：10G100G也是有代价的
    3. 流量清洗：
       1. 从攻击流量中识别出正常访问请求
13. 不上云，
    1. 传统业务
    2. 纯流量型业务：视频分发
14. 面试题：
    1. 你们用了什么云服务？
    2. 都用了哪些功能？
    3. 多少钱？